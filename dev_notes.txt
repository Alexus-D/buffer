ФАЙЛ ЗАМЕТОК ДЛЯ КОНТЕКСТА РАЗРАБОТКИ
=====================================

ДАТА СОЗДАНИЯ: 2025-10-09

=============================================================================
ВАЖНЫЕ ПРАВИЛА И ОГРАНИЧЕНИЯ
=============================================================================

1. СТРОГО следовать плану dev_plan.txt
2. НЕ добавлять лишнюю функциональность без указания пользователя
3. Все изменения фиксировать в этом файле
4. Обновлять dev_plan.txt после каждого этапа
5. Не создавать тестовые файлы или тесты без указания
6. Перед началом выполнения следующего этапа проверять, какие изменения внёс пользователь
7. Все импорты должны быть в начале файла (PEP 8), не внутри функций
8. Перед началом реализации этапа проверить ВСЕ файлы в главной директории проекта кроме файлов в поддиректориях и скорректировать предыдущие пункты плана, чтобы он соответствовал текущему состоянию проекта, также внести туда записи об изменениях, добавленных пользователем

=============================================================================
ФИЗИЧЕСКИЕ ФОРМУЛЫ И МОДЕЛИ
=============================================================================

Модель S-параметра для одной моды:
S = 1 + κ / (cavity_denominator - coupling_term / magnon_denominator)

где:
- cavity_denominator = i(ω - ωc) - (κ + β)
- coupling_term = (iJ + Γ)²
- magnon_denominator = i(ω - ωm) - (γ + α)
- ωm = γ_g * H (линейная дисперсия магнонов)

Для многих мод - суммирование coupling_term_i / magnon_denominator_i

Диссипативная связь: Γ = √(κ * γ)

Единицы измерения:
- Частоты: ГГц (в формулах преобразуются в рад/с через умножение на 2π)
- Магнитное поле: Эрстеды (Э)
- Гиромагнитное отношение: ГГц/Э

=============================================================================
АРХИТЕКТУРА ПРОЕКТА (ЭТАП 1 - ЗАВЕРШЕН)
=============================================================================

Структура модулей:
1. main.py - точка входа, основная логика
2. config_physics.py - физические константы и начальные значения
3. config_fitting.py - параметры оптимизации и границы
4. config_data.py - пути к файлам и настройки I/O
5. models.py - физические модели S-параметров
6. data_io.py - загрузка/сохранение данных
7. visualization.py - построение графиков
8. fitting.py - функции фиттинга данных (добавлен в Этапе 6)
9. interactive.py - интерактивный выбор параметров (добавлен в Этапе 9)

=============================================================================
ТЕКУЩЕЕ СОСТОЯНИЕ (ЭТАП 2 - ЗАВЕРШЕН)
=============================================================================

ИЗМЕНЕНИЯ, ВНЕСЕННЫЕ ПОЛЬЗОВАТЕЛЕМ В ЭТАП 1:
- config_physics.py: убрали разделение на S12/S21, используем один файл данных
- config_data.py: один файл FILENAME вместо S12_FILENAME и S21_FILENAME
- config_data.py: формат данных 'db_amplitude' вместо 'db_phase'
- config_data.py: SKIP_ROWS = 0 (нет заголовков в файле)
- config_fitting.py: убрали секцию TWO_STAGE_FITTING
- models.py: функции переименованы:
  * theoretical_s_parameter -> anticrossing_one_mode_model
  * theoretical_s_parameter_multimode -> anticrossing_multimode_model
  * calculate_coherent_coupling удалена
  * calculate_dissipative_coupling_formula -> calculate_dissipative_coupling
- visualization.py: plot_cavity_fit_contour -> plot_cavity_fit
- visualization.py: plot_residuals работает с контурными картами, а не линейными данными
- data_io.py: убраны функции load_both_s_parameters, parse_complex_data

ИЗМЕНЕНИЯ, ВНЕСЕННЫЕ ПОЛЬЗОВАТЕЛЕМ В ЭТАП 3:
- config_physics.py: добавлена константа MIN_VALID_FIELD = 10 (Э)
  * Минимальное валидное значение поля для фильтрации данных
  
- data_io.py: реализована функция filter_data_by_range(data, field_range, freq_range)
  * Фильтрация данных по диапазонам поля и частоты
  * Если range не указан, используются min/max из данных
  * Применяет маски к freq, field и s_param массивам
  
- data_io.py: load_s_parameter_data() теперь автоматически фильтрует данные
  * После загрузки применяется фильтрация по MIN_VALID_FIELD
  * Убираются данные с полем < MIN_VALID_FIELD

=============================================================================
ЭТАП 2 - ЗАДАЧИ
=============================================================================

ТРЕБУЕТСЯ РЕАЛИЗОВАТЬ:

1. anticrossing_one_mode_model() - модель для одной магнонной моды
   - Вход: freq (ГГц), field (Э), params (dict), s_type
   - Выход: комплексный массив S-параметров
   - Формула: S = 1 + κ / (cavity_part - coupling_term / magnon_part)

2. anticrossing_multimode_model() - модель для нескольких магнонных мод
   - Вход: freq, field, params, num_modes, s_type
   - Выход: комплексный массив S-параметров
   - Формула: суммирование вкладов от каждой моды

3. Калибровка мод по массиву (поле, частота):
   - Использовать FMR_MODE_CALIBRATIONS из config_physics
   - Рассчитывать параметры H0, w0 для каждой моды

=============================================================================
ТЕКУЩИЙ СТАТУС
=============================================================================

Завершено:
- ✓ Этап 1: Создана архитектура проекта (7 модулей)
- ✓ Проанализированы изменения пользователя
- ✓ Этап 2: Реализованы модели антикроссинга

РЕАЛИЗОВАННЫЕ ФУНКЦИИ В ЭТАПЕ 2 (models.py):
1. anticrossing_one_mode_model() - модель S-параметра для одной моды
2. anticrossing_multimode_model() - модель для нескольких мод
3. cavity_only_model() - модель резонатора без магнонов
4. calculate_magnon_frequency_array() - расчет частоты магнонов по полю
5. calculate_dissipative_coupling() - формула Γ = √(κ·γ)
6. convert_to_radians() - конвертация ГГц → рад/с
7. validate_physical_constraints() - проверка физических ограничений

ОСОБЕННОСТИ РЕАЛИЗАЦИИ ЭТАПА 2:
- Все параметры (кроме частот) преобразуются в рад/с через умножение на 2π×10^9
- Частоты магнонов рассчитываются как: ωm = w0 + γ_g * (H - H0)
- В многомодовой модели суммируются вклады от каждой моды
- Калибровка мод через массив (H0, w0) точек

РЕАЛИЗОВАННЫЕ ФУНКЦИИ В ЭТАПЕ 3 (data_io.py, main.py):
1. load_s_parameter_data() - загрузка данных из текстового файла (AI)
2. filter_data_by_range() - фильтрация данных по диапазонам (ПОЛЬЗОВАТЕЛЬ)
3. main() - главная функция с загрузкой данных (AI)

ОСОБЕННОСТИ РЕАЛИЗАЦИИ ЭТАПА 3:
- Формат файла: 1-я строка - частоты, 1-й столбец - поля, остальное - S-параметры
- Автоопределение типа S-параметра из имени файла ("S21" или "S12")
- Преобразование из dB в амплитуду: |S| = 10^(dB/20)
- Пока загружается только амплитуда (без фазы)
- Автоматическая фильтрация данных по MIN_VALID_FIELD = 10 Э (пользователь добавил)
- filter_data_by_range() реализована пользователем для фильтрации по диапазонам

РЕАЛИЗОВАННЫЕ ФУНКЦИИ В ЭТАПЕ 4 (visualization.py, data_io.py, main.py):
1. plot_contour_map() - построение контурной карты S-параметра
2. create_results_directory() - создание директории результатов с timestamp
3. main() обновлено - создание результатов, построение и сохранение графика

ОСОБЕННОСТИ РЕАЛИЗАЦИИ ЭТАПА 4:
- Контурная карта строится с использованием contourf (50 уровней)
- Амплитуда отображается в dB: 20*log10(|S|)
- Параметр show=False по умолчанию, если show=True - график выводится на экран
- Директория результатов создается с timestamp: run_YYYYMMDD_HHMMSS
- Графики сохраняются в формате PNG с DPI=300

РЕАЛИЗОВАННЫЕ ФУНКЦИИ В ЭТАПЕ 5 (generate_test_data.py, main.py, config_data.py, data_io.py):
1. generate_test_data.py - новый автономный модуль для генерации тестовых данных
2. generate_anticrossing_one_mode() - генерация одной моды с шумом
3. generate_anticrossing_multimode() - генерация нескольких мод с шумом
4. add_noise() - добавление гауссовского шума с заданным SNR
5. save_test_data() - сохранение в текстовый формат
6. save_test_data_npz() - сохранение в NPZ формат (в data_io.py)
7. main() обновлено - работает с тестовыми данными

ОСОБЕННОСТИ РЕАЛИЗАЦИИ ЭТАПА 5:
- Параметры генерации: частоты 3.4-3.9 ГГц (100 точек), поля 2880-2920 Э (80 точек)
- SNR по умолчанию 40 dB
- Калибровочные точки для мод задаются списком MODE_CALIBRATIONS
- Автоматическое определение числа мод из длины списка
- Раздельные директории: test_data/ для данных, test_results/ для результатов
- Генератор работает автономно, можно запускать отдельно от main.py
- Шум добавляется к комплексным S-параметрам (real и imag компоненты)

РЕАЛИЗОВАННЫЕ ФУНКЦИИ В ЭТАПЕ 6 (fitting.py, config_physics.py, config_fitting.py, main.py):
1. fitting.py - новый модуль для функций фиттинга (AI)
2. fit_spectrum_one_mode() - фиттинг амплитуды S-параметра для одного поля (AI)
3. config_physics.py обновлен - параметры из generate_test_data.py (AI)
4. config_fitting.py обновлен - границы параметров ±20% от начальных (AI)
5. main.py обновлено - фиттинг для всех полей, сохранение и вывод результатов (AI + ПОЛЬЗОВАТЕЛЬ)

ОСОБЕННОСТИ РЕАЛИЗАЦИИ ЭТАПА 6:
- Создан отдельный модуль fitting.py для функций фиттинга
- Используется scipy.optimize.curve_fit для подгонки параметров
- Границы параметров установлены как ±20% от начальных значений из config_physics.py
- Фиттинг выполняется для амплитуды |S| в линейной шкале
- Функция принимает field_value как скаляр (не массив) - оптимизация
- Функция фиттит спектр при заданном поле и возвращает все параметры модели
- Результаты сохраняются в текстовый файл с таблицей параметров для каждого поля
- Вычисляются и выводятся средние значения всех параметров и метрики качества (R², RMSE)
- Прогресс фиттинга выводится каждые 10 спектров

ИЗМЕНЕНИЯ ПОЛЬЗОВАТЕЛЯ В ЭТАПЕ 6:
- Требование вынести функцию фиттинга в отдельный модуль fitting.py
- Оптимизация: передача field_value как скаляра вместо создания массива
- Исправлены импорты по PEP 8 (убраны pandas, matplotlib из main.py)
- Изменены пути загрузки/сохранения: TEST_FILEPATH и TEST_RESULTS_DIR

РЕАЛИЗОВАННЫЕ ФУНКЦИИ В ЭТАПЕ 7 (fitting.py, visualization.py, main.py):
1. fit_all_spectra() - аппроксимация всех спектров (AI)
   - Выполняет фиттинг для каждого значения поля
   - Возвращает список результатов и восстановленные данные
   - Выводит прогресс выполнения

2. plot_comparison_contours() - визуализация сравнения (AI)
   - Три контурные карты: экспериментальные, подогнанные, остатки
   - Общая шкала для первых двух графиков
   - Симметричная шкала (RdBu_r) для остатков
   - Сохранение и отображение на экране

3. main.py обновлено - использование новых функций (AI)
   - Вызов fit_all_spectra() вместо цикла по спектрам
   - Построение сравнительных графиков после фиттинга
   - Сохранение comparison_contours_S21.png

ОСОБЕННОСТИ РЕАЛИЗАЦИИ ЭТАПА 7:
- fit_all_spectra() инкапсулирует логику фиттинга всех спектров
- Восстановленные данные имеют ту же структуру что и исходные
- Контурные карты располагаются горизонтально (1 строка, 3 столбца)
- Разница вычисляется в dB: (эксп. - фит)
- Цветовая схема viridis для данных, RdBu_r для остатков
- Все три графика сохраняются в один файл PNG

ИЗМЕНЕНИЯ ПОЛЬЗОВАТЕЛЯ В ЭТАПЕ 7:
- Изменена логика фиттинга для улучшения качества подгонки:
  * Фиксированные параметры: wc, kappa, beta (резонатор)
  * Фиксированные параметры: H0, w0, gamma_g (резонансная частота магнонов)
  * Параметры для фиттинга: J, gamma, alpha (только связь и потери магнонов)
  * Gamma вычисляется автоматически: Gamma = sqrt(kappa * gamma)
- Это уменьшает число свободных параметров с 7 до 3, улучшая сходимость

РЕАЛИЗОВАННЫЕ ФУНКЦИИ В ЭТАПЕ 8 (visualization.py, main.py):
1. plot_fitted_parameters_vs_field() - графики параметров vs поле (AI)
   - 4 графика (2x2): J, gamma, alpha, Gamma
   - Каждый график показывает зависимость от магнитного поля
   - Красная пунктирная линия - среднее значение параметра
   - Сохранение в fitted_parameters_vs_field.png

2. plot_fitting_errors_vs_field() - графики ошибок vs поле (AI)
   - 4 графика (2x2): R² vs поле, RMSE vs поле, гистограмма R², гистограмма RMSE
   - Линейные графики показывают зависимость метрик от поля
   - Гистограммы показывают распределение метрик
   - Красная линия - среднее, оранжевая - медиана
   - Сохранение в fitting_errors_vs_field.png

3. main.py обновлено - добавлена визуализация результатов (AI)
   - Преобразование результатов фиттинга в нужный формат
   - Вызов plot_fitted_parameters_vs_field()
   - Вызов plot_fitting_errors_vs_field()
   - Графики выводятся на экран (show=True) и сохраняются

ОСОБЕННОСТИ РЕАЛИЗАЦИИ ЭТАПА 8:
- Графики параметров: линейные с маркерами, grid, legend
- Графики ошибок: комбинация линейных графиков и гистограмм
- Разные цвета для разных параметров (#1f77b4, #ff7f0e, #2ca02c, #d62728, #9467bd, #8c564b)
- Гистограммы с 30 бинами, полупрозрачные (alpha=0.7)
- Все графики с общим заголовком (suptitle)
- DPI=300 для высокого качества сохранения

РЕАЛИЗОВАННЫЕ ФУНКЦИИ В ЭТАПЕ 9 (interactive.py, main.py):
1. interactive.py - новый модуль для интерактивного взаимодействия (AI)
   - Класс InteractiveParameterSelector для выбора параметров кликами мыши
   - Кнопки управления: калибровка магнона, частота резонатора, ширина магнона, 
     ширина резонатора, расстояние между модами
   - Визуальные маркеры на графике (звездочки, линии, прямоугольники)
   - Сохранение параметров в config_interactive.py

2. plot_interactive_contour_map() - построение интерактивной контурной карты (AI)
   - Контурная карта с кнопками слева
   - Текстовое поле внизу с инструкциями
   - Возможность кликать мышью для указания параметров
   - Кнопки "Сохранить" и "Очистить" для управления данными

3. main.py обновлено - добавлен интерактивный режим (AI)
   - Аргумент командной строки --interactive для запуска интерактивного режима
   - Параметр interactive_mode в функции main()
   - При interactive_mode=True запускается выбор параметров и завершается
   - При interactive_mode=False выполняется обычный анализ

ОСОБЕННОСТИ РЕАЛИЗАЦИИ ЭТАПА 9:
- Интерактивный выбор параметров: клики мышью на контурной карте
- 5 режимов выбора: калибровка магнона, частота резонатора, ширина магнона, 
  ширина резонатора, расстояние между модами
- Многошаговые режимы (ширина требует 2 клика, расстояние - 2 клика)
- Визуальная обратная связь: маркеры, линии, прямоугольники на графике
- Текстовые инструкции внизу графика
- Сохранение в отдельный файл config_interactive.py (не изменяет основные конфиги)
- Кнопка "Очистить" для сброса всех выбранных параметров
- Запуск через: python main.py --interactive

СОХРАНЯЕМЫЕ ПАРАМЕТРЫ В ЭТАПЕ 9:
- INTERACTIVE_MAGNON_CALIBRATIONS - список калибровочных точек [(поле, частота), ...]
- INTERACTIVE_CAVITY_FREQUENCY - частота резонатора (ГГц)
- INTERACTIVE_MAGNON_WIDTHS - список ширин магнонов [(freq_min, freq_max), ...]
- INTERACTIVE_CAVITY_WIDTH - ширина резонатора (freq_min, freq_max)
- INTERACTIVE_MODE_SEPARATIONS - расстояния между модами (словарь с деталями)

=============================================================================
ЭТАП 10: ПРЕДВАРИТЕЛЬНЫЙ ФИТТИНГ РЕЗОНАТОРА - ЗАВЕРШЕН
=============================================================================

РЕАЛИЗОВАННЫЕ ФУНКЦИИ В ЭТАПЕ 10:
1. interactive.py - добавлен режим выбора диапазона фиттинга резонатора (AI)
   - Новая кнопка "Диапазон фита\nрезонатора" (6-я кнопка)
   - Метод _mode_cavity_fit_region() - начало режима выбора диапазона
   - Метод _handle_cavity_fit_region() - обработка двух кликов для выделения прямоугольной области
   - Параметр cavity_fit_region сохраняется как dict: {'freq_range': (min, max), 'field_range': (min, max)}
   - Визуализация: циановый прямоугольник (cyan, alpha=0.8, linewidth=2)

2. fitting.py - добавлены функции фиттинга резонатора (AI)
   - estimate_cavity_parameters_from_interactive() - извлечение начальных параметров резонатора
     из интерактивно выбранных данных (wc, kappa, beta)
   - fit_cavity_only() - фиттинг резонатора в выбранном диапазоне
     * Фильтрация данных по freq_range и field_range
     * Усреднение по полю (резонатор не зависит от поля)
     * Фиттинг с помощью models.cavity_only_model()
     * Возвращает: fitted_params, fit_quality (R², RMSE), fitted_spectrum

3. visualization.py - добавлена функция визуализации фиттинга резонатора (AI)
   - plot_cavity_fit_cross_section() - график экспериментальных и фитированных данных
     * Два подграфика: верхний - данные в dB, нижний - остатки (residuals)
     * Экспериментальные данные: синие круги с линией
     * Фитированные данные: красные квадраты с линией
     * Текстовое поле с метриками R² и RMSE
     * График остатков с нулевой линией

4. main.py - обновлен для интеграции фиттинга резонатора (AI)
   - После завершения интерактивного выбора проверяется cavity_fit_region
   - Если cavity_fit_region выбран:
     * Создается директория результатов
     * Извлекаются начальные параметры (estimate_cavity_parameters_from_interactive)
     * Выполняется фиттинг резонатора (fit_cavity_only)
     * Строится и сохраняется график (plot_cavity_fit_cross_section)
     * График отображается на экране (show=True)

ОСОБЕННОСТИ РЕАЛИЗАЦИИ ЭТАПА 10:
- Интерактивный выбор диапазона фиттинга: два клика для прямоугольной области
- Визуальная обратная связь: циановый прямоугольник на контурной карте
- Усреднение данных по полю (резонатор не зависит от поля в выбранном диапазоне)
- Начальные параметры: wc из интерактивного выбора, kappa и beta из ширины резонатора
- Фиттинг методом Левенберга-Марквардта (curve_fit с method='trf')
- Границы параметров: ±50% от начальных значений (если не указаны)
- Метрики качества: R² и RMSE
- График остатков для оценки качества подгонки
- Сохранение результата в директории test_results/run_YYYYMMDD_HHMMSS/

СОХРАНЯЕМЫЕ ПАРАМЕТРЫ В ЭТАПЕ 10:
- INTERACTIVE_CAVITY_FIT_REGION - диапазон фиттинга резонатора:
  {'freq_range': (f_min, f_max), 'field_range': (h_min, h_max)}

ВЫХОДНЫЕ ФАЙЛЫ ЭТАПА 10:
- cavity_fit_cross_section.png - график фиттинга резонатора

РЕАЛИЗОВАННЫЕ ФУНКЦИИ В ЭТАПЕ 10 (fitting.py, visualization.py, main.py):
1. interactive.py - добавлен 6-й режим выбора параметров (AI)
   - Кнопка "Диапазон фита резонатора" для выбора области фиттинга
   - Двухкликовый режим выбора прямоугольной области
   - Визуализация выбранного диапазона циановым прямоугольником (alpha=0.8)
   - Сохранение в cavity_fit_region: {'freq_range': (f_min, f_max), 'field_range': (h_min, h_max)}

2. fitting.py - новые функции для фиттинга резонатора (AI)
   - estimate_cavity_parameters_from_interactive() - извлечение начальных параметров
     * Использует cavity_frequency из интерактивного выбора или центр диапазона
     * Оценивает kappa и beta из cavity_width или из 10% диапазона фиттинга
     * Возвращает начальные параметры: wc, kappa, beta
   
   - fit_cavity_only() - фиттинг резонатора в выбранном диапазоне
     * Фильтрует данные по freq_range и field_range
     * Усредняет S-параметр по полю (резонатор не зависит от поля)
     * Использует models.cavity_only_model() для фиттинга
     * Возвращает подогнанные параметры, метрики качества (R², RMSE), восстановленный спектр

3. visualization.py - новая функция визуализации (AI)
   - plot_cavity_fit_cross_section() - график фиттинга резонатора
     * Верхний подграфик: экспериментальные (синие кружки) vs подогнанные данные (красные квадраты)
     * Текстовое поле с метриками качества (R², RMSE)
     * Нижний подграфик: остатки (residuals) с нулевой линией
     * Сохранение в cavity_fit_cross_section.png

4. main.py - интеграция фиттинга резонатора (AI)
   - После интерактивного режима проверяется наличие cavity_fit_region
   - Если выбран диапазон, запускается:
     1. Извлечение начальных параметров
     2. Фиттинг резонатора
     3. Построение и сохранение графика (show=True)
   - Результаты сохраняются в test_results/run_YYYYMMDD_HHMMSS/

ОСОБЕННОСТИ РЕАЛИЗАЦИИ ЭТАПА 10:
- Автоматическая оценка начальных параметров:
  * wc: центр freq_range, если не выбрана частота резонатора
  * width: 10% от freq_range, если не выбрана ширина резонатора
  * kappa = width * 0.9, beta = width * 0.1 (предполагаем внешние потери >> внутренние)
- Усреднение по полю: резонатор не зависит от магнитного поля в выбранном диапазоне
- Фиттинг с границами ±50% от начальных значений (если не указаны)
- Визуализация в dB для лучшей наглядности
- Метрики качества: R² (коэффициент детерминации) и RMSE (среднеквадратичная ошибка)

ИСПОЛЬЗОВАНИЕ ЭТАПА 10:
```bash
python main.py --interactive
```
1. Выбрать "Диапазон фита резонатора"
2. Кликнуть два раза для выделения прямоугольной области
3. (Опционально) Выбрать частоту и ширину резонатора для лучших начальных параметров
4. Нажать "Сохранить"
5. Закрыть окно - автоматически запустится фиттинг резонатора

СОХРАНЯЕМЫЕ ПАРАМЕТРЫ В ЭТАПЕ 10:
- INTERACTIVE_CAVITY_FIT_REGION - диапазон для фиттинга резонатора

ИСПРАВЛЕННЫЕ ОШИБКИ В ЭТАПЕ 10:
- BUG: estimate_cavity_parameters_from_interactive() падала с TypeError, если cavity_frequency=None
  FIX: Добавлена проверка на None, используется центр freq_range как fallback

- BUG: cavity_only_model() вызывалась с лишним аргументом s_type
  FIX: Удален аргумент s_type из вызова (функция принимает только 4 аргумента)

- BUG: Поиск FWHM был неправильным (искался максимум вместо минимума, полувысота определялась неправильно)
  FIX: Исправлено на поиск минимума (провал резонатора), полувысота = 0.5 в линейных единицах,
       поиск границ провала (где сигнал <= half_height)

- BUG: interactive.py сохраняла np.float64 в config_interactive.py, что вызывало NameError
  FIX: Преобразование к float() при сохранении cavity_fit_region

- BUG: Фиттинг резонатора давал плохие результаты из-за узких границ параметров
  FIX: Расширены границы: kappa и beta (0.1x - 10x), wc (0.8x - 1.2x) для более робастного фиттинга

- IMPORTANT: cavity_only_model дает R²≈0.76 с истинными параметрами в области вдали от антикроссинга.
  Это достаточно для предварительной оценки параметров резонатора.

РЕЗУЛЬТАТ ЭТАПА 10:
✓ Интерактивный выбор диапазона фиттинга резонатора реализован
✓ Автоматическая оценка начальных параметров по формулам реализована
✓ Фиттинг резонатора с cavity_only_model работает
✓ Визуализация результатов фиттинга реализована
✓ Интеграция в main.py завершена

=============================================================================
ЭТАП 11: ДОДЕЛКА ИНТЕРАКТИВНОСТИ - ЗАВЕРШЕН
=============================================================================

РЕАЛИЗОВАННЫЕ ФУНКЦИИ В ЭТАПЕ 11:
1. fitting.py - добавлены функции для автоматической калибровки (AI)
   - find_dip_around_point() - поиск яркого провала в окрестности клика
     * Параметры: data, freq_click, field_click, search_radius_freq=0.05, search_radius_field=10
     * Ищет минимум амплитуды S-параметра в прямоугольной области
     * Возвращает: (field_dip, freq_dip), dip_value
     * Обработка случая, когда нет данных в окрестности
   
   - estimate_coherent_coupling_from_separation() - оценка J из расстояния между модами
     * Извлекает расстояния из interactive_params['mode_separations']
     * Формула: J ≈ среднее_расстояние между модами
     * Физика: расщепление в антикроссинге пропорционально J
     * Возвращает: J_estimate в ГГц или None

2. interactive.py - обновлена калибровка магнонов (AI)
   - _handle_magnon_calibration() - автоматический поиск провала
     * Вызывает find_dip_around_point() при каждом клике
     * Использует найденную точку провала вместо точки клика
     * Визуализирует обе точки (клик - крестик, провал - звездочка)
     * Обработка ошибок: если автопоиск не удался, используется точка клика

3. main.py - использование интерактивных параметров (AI)
   - Обновлена подготовка initial_params:
     * Проверка наличия interactive_params
     * Приоритет параметров: интерактивные > подогнанные > config_physics
     * Отдельные блоки для резонатора, магнонов и когерентной связи
     * Вывод информации о том, какие параметры используются
   
   - Калибровка магнонов из интерактивного режима:
     * Извлечение magnon_calibrations из interactive_params
     * Использование первой моды для одномодовой модели
     * Вывод всех калибровочных точек
   
   - Когерентная связь из расстояния между модами:
     * Вызов estimate_coherent_coupling_from_separation()
     * Использование оценки J вместо значения из config_physics
     * Fallback на config_physics, если оценка не удалась

ОСОБЕННОСТИ РЕАЛИЗАЦИИ ЭТАПА 11:
- Автоматический поиск провала:
  * Радиус поиска: ±50 МГц по частоте, ±10 Э по полю
  * Поиск минимума амплитуды в подматрице данных
  * Визуализация: крестик (клик) + звездочка (найденный провал)
  * Graceful degradation: если поиск не удался, используется точка клика

- Оценка когерентной связи:
  * Простая формула: среднее расстояние между модами
  * Физическое обоснование: расщепление ≈ J в режиме антикроссинга
  * Консервативная оценка для стабильности фиттинга

- Интеграция в main.py:
  * Модульная структура: отдельные проверки для каждого типа параметров
  * Прозрачность: вывод информации о том, какие параметры используются
  * Приоритет: интерактивные параметры имеют наивысший приоритет

ИСПОЛЬЗОВАНИЕ ЭТАПА 11:
```bash
python main.py --interactive
```
1. Выбрать "Калибровка магнона"
2. Кликнуть на провал магнона (автоматический поиск точного минимума)
3. Выбрать "Расстояние между модами"
4. Кликнуть на два провала для измерения расстояния
5. Нажать "Сохранить"
6. Закрыть окно - параметры будут использованы в фиттинге

РЕЗУЛЬТАТ ЭТАПА 11:
✓ Автоматический поиск провала для калибровки магнонов реализован
✓ Оценка когерентной связи из расстояния между модами реализована
✓ Интеграция интерактивных параметров в main.py завершена
✓ Приоритет параметров: интерактивные > подогнанные > config_physics
✓ Прозрачность: вывод информации о том, какие параметры используются

Следующий этап:
- Ожидаем указаний от пользователя
