План разработки проекта

=============================================================================
Этап 1. Создать архитектуру проекта [ЗАВЕРШЕН]
=============================================================================

Создать модульную архитектуру:
    1. main.py - основной файл анализа
    2. config_physics.py - физические константы (частоты, потери, константы)
    3. config_fitting.py - параметры подгонки (границы, методы оптимизации)
    4. config_data.py - конфигурация данных (пути, форматы загрузки/сохранения)
    5. models.py - физические модели для аппроксимации
    6. visualization.py - функции построения графиков
    7. data_io.py - функции загрузки/сохранения данных
    8. fitting.py - функции фиттинга (добавлен в Этапе 6)

Все функции созданы заглушками.

ПРИМЕЧАНИЯ К ИЗМЕНЕНИЯМ В ЭТАПЕ 1:
- Используется один файл данных (не разделение на S12/S21)
- Формат данных: 'db_amplitude' (не 'db_phase')
- SKIP_ROWS = 0 (файл без заголовков)
- Убрано двухэтапное фиттирование из config_fitting.py
- Переименованы функции в models.py:
  * theoretical_s_parameter → anticrossing_one_mode_model
  * theoretical_s_parameter_multimode → anticrossing_multimode_model
- Убраны функции: load_both_s_parameters, parse_complex_data

ИЗМЕНЕНИЯ ПОЛЬЗОВАТЕЛЯ В ЭТАПЕ 3:
- config_physics.py: добавлена MIN_VALID_FIELD = 10 (Э) для фильтрации данных
- data_io.py: реализована filter_data_by_range() - фильтрация по диапазонам
- data_io.py: load_s_parameter_data() автоматически фильтрует данные по MIN_VALID_FIELD

=============================================================================
Этап 2. Модели антикроссинга [ЗАВЕРШЕН]
=============================================================================

Реализовать модели S-параметров для антикроссинга:

1. anticrossing_one_mode_model(freq, field, params, s_type='S21') ✓
   - Модель для одной магнонной моды
   - Формула: S = 1 + κ / (cavity_part - coupling_term / magnon_part)
   - cavity_part = i(ω - ωc) - (κ + β)
   - coupling_term = (iJ + Γ)²
   - magnon_part = i(ω - ωm) - (γ + α)
   - ωm = w0 + γ_g * (H - H0) (линейная дисперсия с калибровкой)

2. anticrossing_multimode_model(freq, field, params, num_modes, s_type='S21') ✓
   - Модель для нескольких магнонных мод
   - Принимает массив калибровочных точек (поле, частота) для каждой моды
   - Суммирует вклады всех мод: Σ(coupling_term_i / magnon_part_i)

3. Вспомогательные функции:
   - cavity_only_model(freq, wc, kappa, beta) ✓ - модель резонатора без магнонов
   - calculate_magnon_frequency_array(field, mode_params) ✓
   - calculate_dissipative_coupling(kappa, gamma) ✓ - формула Γ = √(κ·γ)
   - convert_to_radians(freq_ghz) ✓ - конвертация ГГц → рад/с (×2π × 10^9)
   - validate_physical_constraints(params) ✓ - проверка положительности параметров


=============================================================================
Этап 3. Загрузка данных [ЗАВЕРШЕН]
=============================================================================

1. load_s_parameter_data(filepath) ✓
   - Загрузка данных из текстового файла
   - Формат: 1-я строка - частоты, 1-й столбец - поля, остальное - S-параметры
   - Автоматическое определение типа ("S21" или "S12") из имени файла
   - По умолчанию: "S21"
   - Преобразование из dB в амплитуду: |S| = 10^(dB/20)
   - Автоматическая фильтрация данных по MIN_VALID_FIELD

2. filter_data_by_range(data, field_range, freq_range) ✓ (реализовано пользователем)
   - Фильтрация данных по диапазонам поля и частоты
   - Если диапазон не указан, используются min/max из данных
   - Применяет маски к массивам freq, field и s_param
   
3. main() ✓
   - Загрузка данных из файла, указанного в config_data.FILEPATH
   - Вывод информации о загруженных данных
   - Обработка ошибок (файл не найден, ошибки загрузки)

=============================================================================
Этап 4. Простая визуализация данных [ЗАВЕРШЕН]
=============================================================================

1. plot_contour_map(data, title, save_path, show) ✓
   - Построение контурной карты S-параметра
   - Вычисление амплитуды в dB: 20*log10(|S|)
   - Параметр show=False по умолчанию (не показывать на экране)
   - Если show=True, график выводится на экран
   - Сохранение в файл если указан save_path

2. create_results_directory(base_dir) ✓
   - Создание директории для результатов с timestamp
   - Формат: results/run_YYYYMMDD_HHMMSS

3. main() - обновлено ✓
   - Создание директории результатов
   - Построение контурной карты
   - Сохранение в файл
   - Вывод графика на экран (show=True)

=============================================================================
Этап 5. Генерация тестовых данных [ЗАВЕРШЕН]
=============================================================================

1. generate_test_data.py ✓
   - Автономный файл для генерации тестовых данных
   - Все параметры в начале модуля после импортов
   - Функции:
     * generate_anticrossing_one_mode() - генерация одной моды
     * generate_anticrossing_multimode() - генерация нескольких мод
     * add_noise() - добавление гауссовского шума с заданным SNR
     * save_test_data() - сохранение в текстовый файл
   - Калибровочные точки задаются списком [(поле, частота), ...]
   - Число мод высчитывается из длины списка MODE_CALIBRATIONS
   - Параметр SIGNAL_TO_NOISE_RATIO задает SNR в dB

2. main.py - переделано ✓
   - Теперь загружает тестовые данные из config_data.TEST_FILEPATH
   - Показывает контурную карту тестовых данных
   - Сохраняет данные в формате NPZ
   - Убраны неиспользуемые импорты (numpy, pandas, matplotlib)

3. config_data.py - обновлено ✓
   - Добавлена TEST_DATA_DIR - директория для тестовых данных
   - Добавлена TEST_RESULTS_DIR - директория для результатов тестов
   - Добавлен TEST_FILEPATH - путь к тестовым данным по умолчанию

4. data_io.py - обновлено ✓
   - Добавлена функция save_test_data_npz() для сохранения в NPZ формат


Этап 6. Фиттинг одной тестовой моды [ЗАВЕРШЕН]

ИЗМЕНЕНИЯ ПОЛЬЗОВАТЕЛЯ В ЭТАПЕ 6:
- Исправлены пути: TEST_FILEPATH и TEST_RESULTS_DIR вместо FILEPATH и RESULTS_DIR
- Убраны неиспользуемые импорты из main.py (pandas, matplotlib.pyplot)
- Все импорты приведены к PEP 8 (в начале файлов)
1. Переписать параметры из файла с генерацией теста в файл конфига config_physics.py. ✓
   - Скопированы все параметры резонатора, связи и магнонных мод
   - Обновлены калибровочные точки FMR_MODE_CALIBRATIONS

2. Реализовать функцию фиттинга антикроссинга с одной модой. ✓
   - Создан отдельный модуль fitting.py для функций фиттинга
   - fit_spectrum_one_mode() в fitting.py
   - Использует scipy.optimize.curve_fit
   - Границы параметров: ±20% от начальных значений
   - Фиттит амплитуду |S| в линейной шкале
   - Передает field_value как скаляр (оптимизация по требованию пользователя)
   - Возвращает подогнанные параметры и метрики качества (R², RMSE)

3. Переписать главную функцию проекта. ✓
   - Загрузка тестовых данных
   - Отображение контурной карты
   - Фиттинг спектров для каждого значения поля
   - Сохранение результатов в текстовый файл (таблица параметров)
   - Вывод средних значений параметров в консоль
   - Вывод средних метрик качества (R², RMSE)

4. config_fitting.py обновлен ✓
   - Границы параметров установлены как ±20% от начальных значений
   - CAVITY_PARAM_BOUNDS: wc, kappa, beta
   - FULL_PARAM_BOUNDS: J, Gamma, gamma, alpha

=============================================================================
Этап 7. Простая визуализация ошибки фиттинга [ЗАВЕРШЕН]
=============================================================================

1. Реализовать аппроксимацию спектров при всех полях ✓
   - fit_all_spectra() в fitting.py
   - Выполняет фиттинг для каждого значения поля
   - Возвращает список результатов (параметры + метрики качества)
   - Возвращает восстановленные данные (fitted_data)
   - Выводит прогресс выполнения каждые 10 спектров

2. Реализовать функцию plot_comparison_contours ✓
   - Три контурные карты в одном графике (горизонтально)
   - График 1: Экспериментальные данные (viridis)
   - График 2: Подогнанные данные (viridis)
   - График 3: Остатки = эксп. - фит (RdBu_r, симметричная шкала)
   - Общая шкала для первых двух графиков
   - Сохранение в PNG и отображение на экране

3. Переписать главную функцию проекта ✓
   - Использует fit_all_spectra() вместо цикла по спектрам
   - После сохранения результатов вызывает plot_comparison_contours()
   - Сохраняет comparison_contours_S21.png в директорию результатов
   - Выводит сравнительные графики на экран

4. Всё реализовано для тестовых данных ✓
   - Загрузка из TEST_FILEPATH
   - Сохранение в TEST_RESULTS_DIR

ИЗМЕНЕНИЯ ПОЛЬЗОВАТЕЛЯ В ЭТАПЕ 7:
- Изменена логика фиттинга для улучшения качества:
  * Фиксированы параметры резонатора (wc, kappa, beta)
  * Фиксирована резонансная частота магнонов (H0, w0, gamma_g)
  * Фиттинг только 3 параметров: J, gamma, alpha
  * Gamma = sqrt(kappa * gamma) вычисляется автоматически
  * Уменьшение числа параметров с 7 до 3 улучшает сходимость

Возможные направления развития:
- Визуализация результатов фиттинга (графики параметров vs поле)
- Многомодовый фиттинг
- Анализ качества фиттинга
- Экспорт данных в различные форматы

Этап 8. Улучшенная визуализация результатов фита [ЗАВЕРШЕН]

1. Реализовать функцию, которая будет строить графики зависимостей полученных подогнанных параметров от поля, сохранять их и выводить на экран. ✓
   - plot_fitted_parameters_vs_field() в visualization.py
   - 4 графика (2x2): J, gamma, alpha, Gamma vs поле
   - Каждый график показывает среднее значение (красная пунктирная линия)
   - Сохранение в fitted_parameters_vs_field.png

2. Реализовать функцию, которая аналогично будет визуализировать ошибки подгонки и их зависимости от поля. ✓
   - plot_fitting_errors_vs_field() в visualization.py
   - 4 графика (2x2): R² vs поле, RMSE vs поле, гистограмма R², гистограмма RMSE
   - Гистограммы показывают среднее и медиану
   - Сохранение в fitting_errors_vs_field.png

3. Переписать главную функцию проекта ✓
   - Добавлен вызов plot_fitted_parameters_vs_field()
   - Добавлен вызов plot_fitting_errors_vs_field()
   - Преобразование результатов фиттинга в нужный формат
   - Графики выводятся на экран (show=True) и сохраняются

ОСОБЕННОСТИ РЕАЛИЗАЦИИ ЭТАПА 8:
- Графики параметров: линейные графики с маркерами и средними значениями
- Графики ошибок: линейные графики + гистограммы распределения
- Цветовая схема: разные цвета для разных параметров
- Гистограммы показывают среднее (красная линия) и медиану (оранжевая линия)
- Все графики сохраняются в формате PNG с DPI=300
- Параметр show=True для отображения графиков на экране

Этап 9. Получение начальных приблежений подгонки интерактивным путём [ЗАВЕРШЕН]

В этом этапе нужно реализовать на контурной карте способ получать начальные параметры подгонки по клику мыши. Для этого:
1. Учесть, что на контурной карте не получится выделить абстрактные внешние и внутренние потери и, тем более, когерентную и диссипативную связи. Можно указать лишь положение и ширину пика. ✓
2. Реализовать на графике кнопки, нажатие на которые запускает режим выбора соответствующего параметра: калибровка магнонной моды; значение частоты резонатора; ширина магнонной моды, ширина моды резонатора, расстояние между модами. ✓
3. По нажатию на эти кнопки должен запускаться режим, задающий эти параметры кликами мыши по контурному графику и сохраняющий их в конфигурационный файл. ✓
4. На данном этапе не нужно пока извлекать что-то из ширин пиков или расстояния между модами. Пока достаточно их записать в конфиг. ✓
5. Все вспомогательные функции и объекты, касающиеся интерактивного взаимодействия с контурной картой надо вынести в отдельный файл (сейчас такого файла нет, его нужно создать). ✓

РЕАЛИЗАЦИЯ:
- Создан новый модуль interactive.py
- Класс InteractiveParameterSelector для управления интерактивным выбором
- 5 кнопок: "Калибровка магнона", "Частота резонатора", "Ширина магнона", "Ширина резонатора", "Расстояние между модами"
- Дополнительные кнопки: "Сохранить", "Очистить"
- Визуальные маркеры на графике (звездочки для калибровки, линии для частоты резонатора, прямоугольники для ширин)
- Текстовые инструкции внизу графика
- Сохранение параметров в config_interactive.py
- Запуск через: python main.py --interactive

СОХРАНЯЕМЫЕ ПАРАМЕТРЫ:
- INTERACTIVE_MAGNON_CALIBRATIONS - калибровочные точки магнонов
- INTERACTIVE_CAVITY_FREQUENCY - частота резонатора
- INTERACTIVE_MAGNON_WIDTHS - ширины магнонных мод
- INTERACTIVE_CAVITY_WIDTH - ширина резонатора
- INTERACTIVE_MODE_SEPARATIONS - расстояния между модами

Этап 10. Предварительная подгонка параметров резонатора
Теперь нужно реализовать получение параметров для конкретно резонатора.
1. На первоначальной контурной карте добавить кнопку, по нажатию на которую можно будет выбрать диапазон частот и поле, в котором нужно зафитить пик отдельно резонатора с помощью уже реализованной модели.
2. Реализовать функцию, которая будет принимать этот диапазон, а также полученные в интерактивном режиме частоту резонатора и ширину его пика, искать значение в пике резонатора в полученном диапазоне и, исходя из формулы фита отдельного резонатора, возвращать приблизительные начальные параметры для фита резонатора.
3. Реализовать функцию фита отдельно резонатора по параметрам, полученным из 2 пункта этого этапа.
4. Реализовать функцию, которая будет строить срез графика в указанном в 1 пункте этого этапа диапазоне и восстановленный срез по подогнанным параметрам отдельно резонатора, сохранять этот график и выводить его на экран.
5. Изменить основную функцию проекта, чтобы она после интерактивного режима запускала фит отдельно резонатора, показывала график из пункта 3 этого этапа полученные значения резонатора в дальнейшем использовала для фита антикроссинга.

Этап 11. Доделка интерактивности [ЗАВЕРШЕН]

1. Теперь нужно, чтобы начальные параметры для калибровки магнонной моды при фиттинге всего антикроссинга основной функции проекта брались из интерактивного режима, а не из конфига. Для этого нужно реализовать функцию, которая найдёт яркий провал в точке клика и сделает по нему соответствующую калибровку магнонной моды. ✓
2. Кроме того, нужно из интерактивного режима оценить когерентную связь, как расстояние между модами (там как раз реализован метод нахождения расстояния между модами). Уже эту связь надо использовать в качестве начального значения при подгонке в основной функции проекта. ✓

РЕАЛИЗАЦИЯ:
- fitting.py: добавлена функция find_dip_around_point() - поиск провала в окрестности клика
  * Параметры поиска: ±0.05 ГГц по частоте, ±10 Э по полю
  * Находит минимум амплитуды S-параметра в указанной области
  * Возвращает калибровочную точку (field, freq) и значение в провале

- fitting.py: добавлена функция estimate_coherent_coupling_from_separation()
  * Оценивает когерентную связь J из расстояния между модами
  * Формула: J ≈ среднее(расстояния между модами)
  * Возвращает оценку J в ГГц или None, если расстояния не указаны

- interactive.py: обновлена функция _handle_magnon_calibration()
  * Автоматически вызывает find_dip_around_point() при клике
  * Рисует маркер в найденной точке провала, а не в точке клика
  * Визуализирует точку клика (крестик) для наглядности поиска

- main.py: обновлена подготовка начальных параметров
  * Проверяет наличие интерактивных параметров (magnon_calibrations)
  * Использует калибровку из интерактивного режима вместо config_physics
  * Оценивает J из mode_separations через estimate_coherent_coupling_from_separation()
  * Выводит информацию о том, какие параметры используются (интерактивные или из конфига)

ОСОБЕННОСТИ РЕАЛИЗАЦИИ ЭТАПА 11:
- Автоматический поиск провала делает калибровку более точной и удобной
- Радиус поиска настраиваемый (по умолчанию ±50 МГц и ±10 Э)
- Если поиск не удался, используется точка клика как есть
- Оценка J из расстояния между модами дает хорошее начальное приближение
- Все параметры выводятся в консоль для прозрачности
- Приоритет параметров: интерактивные > подогнанные > config_physics

=============================================================================
СПИСОК НЕРЕАЛИЗОВАННЫХ ЗАГЛУШЕК
=============================================================================

config_fitting.py:
  - get_initial_params() - получить начальные параметры для фиттинга
  - get_param_bounds() - получить границы параметров для оптимизации

config_data.py:
  - ensure_directories() - создать директории, если не существуют
  - get_data_paths() - получить пути к файлам данных

data_io.py:
  - save_fitted_parameters(params, filepath) - сохранить параметры
  - save_fitted_data(data, filepath) - сохранить данные
  - export_to_csv(data, filepath) - экспорт в CSV
  - export_to_json(data, filepath) - экспорт в JSON

visualization.py:
  - plot_cavity_fit(data, cavity_params, save_path) - график фиттинга резонатора
  - plot_cross_sections(data, field_values, freq_values, save_path) - срезы
  - plot_magnon_dispersion(field, params, save_path) - дисперсия магнонов
  - plot_anticrossing_diagram(data, fitted_params, save_path) - диаграмма антикроссинга
  - plot_residuals(experimental, fitted, save_path) - контурная карта остатков (заглушка, но есть реализация в plot_comparison_contours)
  - plot_fitting_quality(data, metrics, save_path) - качество подгонки (заглушка, но есть реализация в plot_fitting_errors_vs_field)
  - configure_plot_style() - настройка стиля matplotlib
  - save_figure(fig, filepath, dpi, format) - сохранение фигуры

ПРИМЕЧАНИЕ: 
- plot_fitted_parameters_vs_field() и plot_fitting_errors_vs_field() реализованы в Этапе 8
- Они дублируют функциональность заглушек plot_fitting_quality() и частично plot_residuals()

